# Referent Analysis: Why Some Expressions Return Multiple Objects

## Summary

The referring expressions generated by the pipeline are **working correctly**. The issue is not a bug, but rather a fundamental aspect of how referring expressions work in natural language.

## Key Findings

### 1. No `filter_unique` Nodes in Generated Expressions
- **0 out of 20** expressions contain `filter_unique` nodes
- This means expressions are designed to return **all objects** that match the description, not necessarily unique objects

### 2. Expression Types and Their Behavior

| Expression Type | Example | Referents | Reason |
|----------------|---------|-----------|---------|
| **Single Referent** | "The second one of the tiny object(s) from right" | 1 object | Uses ordinal selection (`filter_ordinal`) |
| **Multiple Referents** | "The things that are metal thing(s) or brown thing(s)" | 2+ objects | Uses union operations (`union`) |
| **Multiple Referents** | "The objects that are metallic cylinder(s) that are in front of..." | 2+ objects | Complex spatial relationships can match multiple objects |

### 3. Why Multiple Referents Occur

#### A. Union Operations (`union` nodes)
```json
{
  "type": "union",
  "inputs": [node1, node2]
}
```
- Combines results from multiple filter operations
- Naturally produces multiple referents when both sets are non-empty

#### B. Complex Spatial Relationships
- "Objects that are to the right of X and to the left of Y" can match multiple objects
- "Objects that are in front of Z" can match multiple objects if Z is large or positioned such that multiple objects are in front of it

#### C. Ambiguous Descriptions
- "The things that are metal thing(s) or brown thing(s)" explicitly asks for multiple objects
- "The objects that are metallic cylinder(s)" can match multiple metallic cylinders

## Examples from Generated Data

### Expression 1: Multiple Referents (Expected)
```
Text: "Look at thing that is in front of the second one of the metallic object(s) from right; The first one of the thing(s) from front that are on the left side of it"
Program: ['scene', 'filter_material', 'filter_ordinal', 'unique', 'relate', 'unique', 'relate', 'filter_size']
Result: [1, 3] (green cylinder, brown cylinder)
```
**Why multiple referents**: Both green and brown cylinders are large objects to the left of the gray cube.

### Expression 4: Multiple Referents (Expected)
```
Text: "The things that are metal thing(s) or gray block(s)"
Program: ['scene', 'filter_material', 'scene', 'filter_color', 'filter_shape', 'union']
Result: [1, 3, 4, 5] (all metal objects + gray cube)
```
**Why multiple referents**: Uses `union` operation to combine metal objects and gray blocks.

### Expression 7: Single Referent (Expected)
```
Text: "The second one of the tiny object(s) from right"
Program: ['scene', 'filter_size', 'filter_ordinal']
Result: [4] (gray cube)
```
**Why single referent**: Uses ordinal selection to pick the second tiny object from the right.

## Conclusion

**The expressions are working as designed.** The pipeline generates referring expressions that can refer to:
- Single objects (when uniquely identifiable)
- Multiple objects (when the description applies to multiple objects)

This is consistent with natural language referring expressions, where:
- "The red ball" → single object
- "The red balls" → multiple objects
- "The objects to the left of the table" → potentially multiple objects

## Recommendations

If you need expressions that always return unique referents, you would need to:

1. **Modify the templates** to always end with `filter_unique` nodes
2. **Add post-processing** to ensure uniqueness
3. **Use different templates** that are designed for unique identification
4. **Accept that some expressions naturally refer to multiple objects**

The current behavior is linguistically and logically correct.
