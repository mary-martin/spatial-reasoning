# Copyright 2017-present, Facebook, Inc.
# All rights reserved.
#
# This source code is licensed under the BSD-style license found in the
# LICENSE file in the root directory of this source tree. An additional grant
# of patent rights can be found in the PATENTS file in the same directory.

from __future__ import print_function
import argparse, json, os, itertools, random, shutil
import time
import re

import rearrangement_engine as reng

# Import the refexp generation utilities
import sys
sys.path.append('../custom_clevr/refexp_generation')
import refexp_engine as qeng

random.seed(10)

"""
Generate synthetic rearrangement expressions for CLEVR-Ref+ images. This script takes
existing referring expressions and generates corresponding rearrangement expressions
that specify where to place the referenced objects.

Rearrangement expressions are generated by:
1. Taking existing referring expressions that identify objects
2. Finding valid placement relations that don't already exist in the scene
3. Generating paired expressions that specify where to place the identified objects
4. Linking the original and rearrangement expressions together

The output includes both the original referring expressions and their corresponding
rearrangement expressions, with linking information to connect them.
"""

parser = argparse.ArgumentParser()

# Inputs
parser.add_argument('--input_refexps_file', 
    default='../custom_clevr/output/clevr_ref+_base_refexps.json',
    help="JSON file containing existing referring expressions")
parser.add_argument('--input_scenes_file', 
    default='../custom_clevr/output/clevr_ref+_scenes.json',
    help="JSON file containing ground-truth scene information")
parser.add_argument('--metadata_file', default='metadata.json',
    help="JSON file containing metadata about functions")
parser.add_argument('--synonyms_json', default='synonyms.json',
    help="JSON file defining synonyms for parameter values")
parser.add_argument('--template_dir', default='rearrangement_templates',
    help="Directory containing JSON templates for rearrangement expressions")

# Output
parser.add_argument('--output_rearrangement_file',
    default='../custom_clevr/output/clevr_ref+_rearrangements.json',
    help="The output file to write containing generated rearrangement expressions")

# Control which and how many expressions to process
parser.add_argument('--refexp_start_idx', default=0, type=int,
    help="The referring expression at which to start generating rearrangements")
parser.add_argument('--num_refexps', default=0, type=int,
    help="The number of referring expressions for which to generate rearrangements. Setting to 0 "
         "generates rearrangements for all expressions starting from --refexp_start_idx")

# Control the number of rearrangements per referring expression
parser.add_argument('--rearrangements_per_refexp', default=1, type=int,
    help="The number of rearrangement expressions to generate for each referring expression")

# Misc
parser.add_argument('--verbose', action='store_true',
    help="Print more verbose output")
parser.add_argument('--max_attempts', default=100, type=int,
    help="Maximum number of attempts to generate a valid rearrangement per referring expression")


def load_scenes_by_image(scenes_data):
    """Load scenes indexed by image filename for quick lookup."""
    scenes_by_image = {}
    for scene in scenes_data['scenes']:
        image_filename = scene['image_filename']
        scenes_by_image[image_filename] = scene
    return scenes_by_image


def extract_object_from_refexp(refexp_data, scene_struct, metadata):
    """
    Extract the target object from a referring expression.
    
    Args:
        refexp_data: Dictionary containing the referring expression data
        scene_struct: Scene structure containing objects
        metadata: Metadata containing type information
    
    Returns:
        Object index if found, None otherwise
    """
    try:
        # Execute the referring expression to get the target object
        program = {'nodes': refexp_data['program']}
        result = qeng.answer_refexp(program, metadata, scene_struct)
        
        # Handle different result types
        if isinstance(result, int) and 0 <= result < len(scene_struct['objects']):
            return result
        elif isinstance(result, list) and len(result) == 1:
            # Single object in a list
            obj_idx = result[0]
            if isinstance(obj_idx, int) and 0 <= obj_idx < len(scene_struct['objects']):
                return obj_idx
        elif isinstance(result, list) and len(result) > 1:
            # Multiple objects - pick the first one
            obj_idx = result[0]
            if isinstance(obj_idx, int) and 0 <= obj_idx < len(scene_struct['objects']):
                return obj_idx
        
        return None
    except Exception as e:
        if args.verbose:
            print(f"Error extracting object from refexp: {e}")
        return None


def find_valid_placement_relations(target_obj_idx, scene_struct, metadata):
    """
    Find valid placement relations for a target object.
    
    Args:
        target_obj_idx: Index of the target object
        scene_struct: Scene structure
        metadata: Metadata containing type information
    
    Returns:
        List of tuples (relation, reference_object_idx) that are valid placements
    """
    valid_placements = []
    
    # Get all other objects in the scene
    all_objects = list(range(len(scene_struct['objects'])))
    other_objects = [idx for idx in all_objects if idx != target_obj_idx]
    
    # For each relation type and each other object
    for relation in metadata['types']['Relation']:
        for ref_obj_idx in other_objects:
            # Check if this relation already exists
            relation_exists = reng.check_relation_exists_handler(
                scene_struct, [target_obj_idx, ref_obj_idx], [relation]
            )
            
            # We want relations that DON'T already exist
            if not relation_exists:
                valid_placements.append((relation, ref_obj_idx))
    
    return valid_placements


def instantiate_rearrangement_template(scene_struct, template, metadata, target_obj_idx, 
                                     reference_obj_idx, relation, synonyms, verbose=False):
    """
    Instantiate a rearrangement template with specific parameters.
    
    Args:
        scene_struct: Scene structure
        template: Template to instantiate
        metadata: Metadata containing type information
        target_obj_idx: Index of the target object
        reference_obj_idx: Index of the reference object
        relation: Relation type
        synonyms: Synonym dictionary
        verbose: Whether to print debug information
    
    Returns:
        Tuple of (text, program, success_flag)
    """
    try:
        # Get the target and reference objects
        target_obj = scene_struct['objects'][target_obj_idx]
        ref_obj = scene_struct['objects'][reference_obj_idx]
        
        # Create parameter values based on the template
        param_vals = {}
        
        # Map template parameters to object properties
        for param in template['params']:
            param_name = param['name']
            param_type = param['type']
            
            if param_name == '<C>':  # Target object color
                param_vals[param_name] = target_obj['color']
            elif param_name == '<S>':  # Target object shape
                param_vals[param_name] = target_obj['shape']
            elif param_name == '<M>':  # Target object material
                param_vals[param_name] = target_obj['material']
            elif param_name == '<C2>':  # Reference object color
                param_vals[param_name] = ref_obj['color']
            elif param_name == '<S2>':  # Reference object shape
                param_vals[param_name] = ref_obj['shape']
            elif param_name == '<M2>':  # Reference object material
                param_vals[param_name] = ref_obj['material']
            elif param_name == '<R>':  # Relation
                param_vals[param_name] = relation
            else:
                # Handle other parameters as needed
                if param_type in metadata['types']:
                    param_vals[param_name] = random.choice(metadata['types'][param_type])
                else:
                    param_vals[param_name] = None
        
        # Generate the program by instantiating the template nodes
        program = []
        for node in template['nodes']:
            new_node = {
                'type': node['type'],
                'inputs': node['inputs']
            }
            if 'side_inputs' in node:
                side_inputs = []
                for side_input in node['side_inputs']:
                    if side_input in param_vals:
                        side_inputs.append(param_vals[side_input])
                    else:
                        side_inputs.append(side_input)
                new_node['side_inputs'] = side_inputs
            program.append(new_node)
        
        # Generate the text by instantiating the template
        text_template = random.choice(template['text'])
        text = text_template
        
        # Replace parameters in the text
        for param_name, param_val in param_vals.items():
            if param_val in synonyms:
                param_val = random.choice(synonyms[param_val])
            text = text.replace(param_name, param_val)
        
        # Clean up the text
        text = ' '.join(text.split())
        
        # Capitalize the first letter
        if text and text[0].islower():
            text = text[0].upper() + text[1:]
        
        return text, program, True
        
    except Exception as e:
        if verbose:
            print(f"Error instantiating template: {e}")
        return None, None, False


def generate_rearrangement_for_refexp(refexp_data, scene_struct, templates, metadata, 
                                    synonyms, refexp_metadata, max_attempts=100, verbose=False):
    """
    Generate a rearrangement expression for a given referring expression.
    
    Args:
        refexp_data: Dictionary containing the referring expression data
        scene_struct: Scene structure
        templates: List of rearrangement templates
        metadata: Metadata containing type information
        synonyms: Synonym dictionary
        max_attempts: Maximum number of attempts to generate a valid rearrangement
        verbose: Whether to print debug information
    
    Returns:
        Dictionary containing the rearrangement expression data, or None if failed
    """
    # Extract the target object from the referring expression
    target_obj_idx = extract_object_from_refexp(refexp_data, scene_struct, refexp_metadata)
    if target_obj_idx is None:
        if verbose:
            print("Could not extract target object from referring expression")
        return None
    
    # Find valid placement relations
    valid_placements = find_valid_placement_relations(target_obj_idx, scene_struct, metadata)
    if not valid_placements:
        if verbose:
            print(f"No valid placement relations found for object {target_obj_idx}")
        return None
    
    # Try to generate a rearrangement expression
    for attempt in range(max_attempts):
        # Choose a random valid placement
        relation, reference_obj_idx = random.choice(valid_placements)
        
        # Choose a random template
        template = random.choice(templates)
        
        # Instantiate the template
        text, program, success = instantiate_rearrangement_template(
            scene_struct, template, metadata, target_obj_idx, 
            reference_obj_idx, relation, synonyms, verbose
        )
        
        if success and text and program:
            # Validate the rearrangement
            rearrangement = {'nodes': program}
            if reng.is_valid_rearrangement(rearrangement, metadata, scene_struct, verbose=verbose):
                return {
                    'refexp': text,
                    'program': program,
                    'target_object': target_obj_idx,
                    'reference_object': reference_obj_idx,
                    'target_relation': relation,
                    'template_used': template.get('name', 'unknown')
                }
    
    if verbose:
        print(f"Failed to generate valid rearrangement after {max_attempts} attempts")
    return None


def main(args):
    # Load metadata
    with open(args.metadata_file, 'r') as f:
        metadata = json.load(f)
        dataset = metadata['dataset']
        if dataset != 'CLEVR-Ref+-v1.0':
            raise ValueError('Unrecognized dataset "%s"' % dataset)
    
    # Load templates
    templates = []
    for fn in os.listdir(args.template_dir):
        if not fn.endswith('.json'): 
            continue
        with open(os.path.join(args.template_dir, fn), 'r') as f:
            for template in json.load(f):
                template['name'] = fn  # Add template name for tracking
                templates.append(template)
    
    print(f'Loaded {len(templates)} rearrangement templates')
    
    # Load referring expressions
    with open(args.input_refexps_file, 'r') as f:
        refexps_data = json.load(f)
        refexps = refexps_data['refexps']
        refexp_info = refexps_data['info']
    
    # Load refexp metadata for execution
    refexp_metadata_file = '../custom_clevr/refexp_generation/metadata.json'
    with open(refexp_metadata_file, 'r') as f:
        refexp_metadata = json.load(f)
    
    # Load scenes
    with open(args.input_scenes_file, 'r') as f:
        scenes_data = json.load(f)
        scenes_by_image = load_scenes_by_image(scenes_data)
    
    # Load synonyms
    with open(args.synonyms_json, 'r') as f:
        synonyms = json.load(f)
    
    # Determine which referring expressions to process
    begin = args.refexp_start_idx
    if args.num_refexps > 0:
        end = args.refexp_start_idx + args.num_refexps
        refexps_to_process = refexps[begin:end]
    else:
        refexps_to_process = refexps[begin:]
    
    print(f'Processing {len(refexps_to_process)} referring expressions')
    
    # Generate rearrangement expressions
    expression_pairs = []
    successful_pairs = 0
    
    for i, refexp_data in enumerate(refexps_to_process):
        image_filename = refexp_data['image_filename']
        
        if image_filename not in scenes_by_image:
            if args.verbose:
                print(f"Scene not found for image {image_filename}")
            continue
        
        scene_struct = scenes_by_image[image_filename]
        
        if args.verbose:
            print(f'Processing referring expression {i+1}/{len(refexps_to_process)}: {refexp_data["refexp"]}')
        
        # Generate rearrangement expressions for this referring expression
        rearrangements = []
        for j in range(args.rearrangements_per_refexp):
            rearrangement = generate_rearrangement_for_refexp(
                refexp_data, scene_struct, templates, metadata, synonyms, refexp_metadata,
                max_attempts=args.max_attempts, verbose=args.verbose
            )
            
            if rearrangement:
                rearrangements.append(rearrangement)
        
        # Create expression pairs
        if rearrangements:
            for rearrangement in rearrangements:
                pair = {
                    'original': {
                        'refexp': refexp_data['refexp'],
                        'program': refexp_data['program'],
                        'answer': refexp_data.get('answer', None),
                        'image_filename': refexp_data['image_filename'],
                        'image_index': refexp_data['image_index']
                    },
                    'rearrangement': rearrangement,
                    'pair_id': f"pair_{len(expression_pairs):06d}",
                    'scene_id': image_filename.replace('.png', ''),
                    'generation_info': {
                        'template_used': rearrangement['template_used'],
                        'target_object': rearrangement['target_object'],
                        'reference_object': rearrangement['reference_object'],
                        'target_relation': rearrangement['target_relation']
                    }
                }
                expression_pairs.append(pair)
                successful_pairs += 1
        
        if (i + 1) % 100 == 0:
            print(f'Processed {i+1} referring expressions, generated {successful_pairs} pairs')
    
    # Write output
    output_data = {
        'info': {
            'license': 'Creative Commons Attribution (CC-BY 4.0)',
            'date': time.strftime('%m/%d/%Y'),
            'split': refexp_info.get('split', 'train'),
            'version': '1.0',
            'description': 'Scene rearrangement expressions paired with original referring expressions',
            'num_original_refexps': len(refexps_to_process),
            'num_successful_pairs': successful_pairs,
            'templates_used': list(set(t['name'] for t in templates))
        },
        'expression_pairs': expression_pairs
    }
    
    with open(args.output_rearrangement_file, 'w') as f:
        print(f'Writing output to {args.output_rearrangement_file}')
        json.dump(output_data, f, indent=2)
    
    print(f'Generated {successful_pairs} expression pairs from {len(refexps_to_process)} referring expressions')


if __name__ == '__main__':
    args = parser.parse_args()
    main(args)
